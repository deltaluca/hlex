package;

import haxe.Int32;
import haxe.io.Bytes;
import haxe.io.BytesInput;
import haxe.io.BytesOutput;
import haxe.io.Input;
import haxe.io.Output;

class HLex {
	public static inline var T_EOF:Int = 0x7F;
	public static inline var T_ERROR:Int = 0xFE;
	
	public static inline function tid(x:Int):Int {
		var id = x & 0x7F;
		return if (id < 124) id else if(id==124) 10 else if (id == 125) 13 else id;
	}
	public static inline function thasData(x:Int):Bool return x & 0x80 != 0
	
	public static inline var X_EOS   :Int = 0;
	public static inline var X_STRING:Int = 1;
	public static inline var X_INT   :Int = 2;
	public static inline var X_DOUBLE:Int = 3;
	
	static inline function xreadByte(inp:Input):Int {
		var v = inp.readByte();
		return if (v == 0xff) {
			switch(inp.readByte()) {
				case 0: 0xff;
				case 1: 0x0a;
				case 2: 0x0d;
			}
		}else v;
	}
	
	static inline function xreadBytes(inp:Input, len:Int):BytesInput {
		var b = new BytesOutput();
		for (i in 0...len) b.writeByte(xreadByte(inp));
		return new BytesInput(b.getBytes());
	}
	
	public static inline function xreadDouble(inp:Input):Float {
		var b = xreadBytes(inp, 8);
		return b.readDouble();
	}
	public static inline function xreadInt32(inp:Input):Int32 {
		var b = xreadBytes(inp, 4);
		return b.readInt32();
	}
	
	public static inline function xreadInt(inp:Input):Int {
		var b0 = xreadByte(inp);
		var b1 = xreadByte(inp);
		var b2 = xreadByte(inp);
		var b3 = xreadByte(inp);
		return (b3<<24)|(b2<<16)|(b1<<8)|b0;
	}
	
	public static inline function xreadString(inp:Input):String {
		var ret = new StringBuf();
		while(true) {
			var b = inp.readByte();
			if(b==0) break;
			ret.addChar(b);
		}
		return ret.toString();
	}
}