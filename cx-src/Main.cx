package;

import scx.Set;
import scx.UStr;
import scx.FA;
import scx.LList;

//using UStr.Unicode;
//using FA.FaUtil(CharSet);

import util.CharSet;
import util.RegExp;

import neko.Sys;
import neko.Lib;
import neko.io.File;

import HLex;
import HLlr;
import scx.Textual;

typedef Rule = { name:String, id:Int, attr:String, nfa:NFA(CharSet), ign:Bool };

class Main {
	static function main() {
		var args = Sys.args();
		
		if(args.length < 3 && args[0]!="--help") {
		    Lib.println("For help use option --help");
			Sys.exit(1);
			return;
		}
		
		if(args[0]=="--help") {
		
		    Lib.println("Usage: hlex descriptor.hxl [options]");
		    Lib.println("Options:");
		    Lib.println("\t-haxe output.hx [-package package_name]");
		    Lib.println("\t\tGenerate a pure haXe lexer in given package. Will generate a class HLex with public static function lexify :: String -> Array<Token> with Tokens defined in same file");
		    Lib.println("");
		    Lib.println("\t-cpp output_exec output_utils.hx");
		    Lib.println("\t\tGenerate an executable (compiling with g++) which can be interfaced with through the utility methods in the haXe output through stdin/stdout via haXe to be fed a stream of input files, and feeding back a stream of tokens with delimiteres to denote file end");
		    Lib.println("");
		    Lib.println("\t-c++ output_name");
		    Lib.println("\t\tGenerates a c++ lexer (output_name.hpp output_name.cpp) for use IN c++ (not haXe) requires utility modules from caxe to define classes used. Like -cpp flag is to be used in a threaded environment passing streams of input files and receiving back a stream of tokens");
            Lib.println("");
			Lib.println("\tFor syntax of hxl view hxl_readme");
			Lib.println("");
			Lib.println("\t-haxe-gen output.hx [-package package_name] for new style haXe lexer using custom tokens which must be defined");
			
		    Sys.exit(0);
		    return;
		}
		
		//------------------------------------------------------------------------------------------
		
		Lib.println(" >> Initialising");
		
		var packname = "";
		var haxemode = true;
		var realcpp = false;
		var newhaxe = false;
		
		var flag = args[1];
		if(flag=="-haxe") haxemode = true;
		else if(flag=="-cpp") haxemode = false;
		else if(flag=="-c++") { haxemode = false; realcpp = true; }
		else if(flag=="-haxe-gen") newhaxe = true;
		else { Lib.println("Unrecognised flag "+flag); Sys.exit(1); }
		
		var iarg = haxemode ? 3 : 3;
		while(iarg < args.length) {
			var flag = args[iarg++];
			if(flag=="-package" && haxemode) packname = args[iarg++];
			else Lib.println("Unrecognised flag "+flag);
		}
		
		//------------------------------------------------------------------------------------------
		
		Lib.println(" >> Lexing descriptor");
		
		var hxl = File.getContent(args[0]);
		var tokens = HLex.lexify(hxl);
		
		var terminals = new Array<Terminal>();
		for(i in tokens) {
			var p = switch(i.id) {
				case Token.t_ident: Terminal.IDENT.inst(i.data);
				case Token.t_int  : Terminal.INT.inst(i.data);
				case Token.t_attrx: Terminal.ATTR;
				case Token.t_lpar: Terminal.LPAR;
				case Token.t_rpar: Terminal.RPAR;
				case Token.t_colon: Terminal.COLON;
				case Token.t_coleq: Terminal.COLEQ;
				case Token.t_regexp: Terminal.REGEXP.inst(i.data);
				case Token.t_haxe:   Terminal.HAXE.inst(i.data);
				case Token.t_NULLx: Terminal.NULL;
				case Token.t_error: Terminal.ERROR;
				case Token.t_err: Terminal.ERR;
				default: null;
			}
			if(p!=null) terminals.unshift(p);
		}
		terminals.unshift(Terminal.DOLLAR);
		
		Lib.println(" >> Parsing descriptor");

		var hlx:Array<HLX> = cast HLlr.parse(terminals);
		
		for(i in Error.errors)
			Lib.println("ERROR: "+i);
		
		if(Error.errors.length>0) Sys.exit(1);
		
		//------------------------------------------------------------------------------------------
		
		Lib.println(" >> Building NFA");
		
		var extra = "";
		var errs = false;
		var rules = new StringMap(Rule)();
		var nfrules = new Array<NFA(CharSet)>();
		var tokenid = 1;
		var error_node:{name:String,id:Int} = null;

		var error_attr = null;
		
		for(S in hlx) {
			switch(S) {
				case hlx_ignore(n,p,reg):
					if(rules.has(n)) {
						Lib.println("ERROR: Rule "+n+" already exists in rule declaration!");
						errs = true;
					}
					var nfa = RegExp.nfa(Unicode.fromString(reg));
					var rule = { name : n, id : -1, nfa : nfa, attr : null, ign : true };
					FaUtil(CharSet).attribute(nfa, p, function(_) return rule);
					
					nfrules.push(nfa);
					rules.insert(n,rule);
				
				case hlx_decl(n,p,reg):
					if(rules.has(n)) {
						Lib.println("ERROR: Rule "+n+" already exists in rule declaration!");
						errs = true;
					}
					var nfa = RegExp.nfa(Unicode.fromString(reg));
					var rule = { name : n, id : tokenid++, nfa : nfa, attr : null, ign : false };
					FaUtil(CharSet).attribute(nfa, p, function(_) return rule);
					
					nfrules.push(nfa);
					rules.insert(n,rule);
					
				case hlx_attr(n, attr):
					var rule = rules.get(n);
					if(rule==null && n!="error_tok") {
						Lib.println("ERROR: Rule "+n+" does not exist in attribute definition!");
						errs = true;
					}
					if(rule!=null)	
						rule.attr = attr;
					else if(n=="error_tok") error_attr = attr;
					
				case hlx_err(n):
					
					if(rules.has(n)) {
						Lib.println("ERROR: Rule "+n+" does not exist in attribute definition!");
						errs = true;
					}
					
					error_node = { name : n, id : tokenid++ };
					
				case hlx_extra(haxe):
					extra += haxe;
			}
		}
		
		if(errs) Sys.exit(1);
		
		//------------------------------------------------------------------------------------------
		
		neko.Lib.println(" >> Building DFA");
		
		var nfa = FaUtil(CharSet).dfa_cons(nfrules);
		var dfa = FaUtil(CharSet).dfa(nfa);
		
		neko.Lib.println(" >> Minimalising DFA");

		dfa = FaUtil(CharSet).minimal(dfa);

		//------------------------------------------------------------------------------------------
		//output to file.
		
		neko.Lib.println(" >> Outputting to file");
		var out = "";
		
		if(!haxemode && realcpp) {
			var out = "";
			out += "#pragma once\n";
			out += "\n";
			out += "#include <string>\n";
			out += "#include <iostream>\n";
			out += "#include <caxe_util.hpp>\n";
			
			out += "struct TOKEN {\n";
			out += "	char id;\n";
			out += "	Dynamic data;\n";
			out += "	TOKEN();\n";
			out += "	TOKEN(char);\n";
			out += "	TOKEN(char, const Dynamic&);\n";
			out += "};\n";
			out += "std::ostream& operator<<(std::ostream&,const TOKEN&);\n";
			
			out += "class Lexer : public Thread {\n";
			out += "	ref<tsDeque<ptr<TOKEN> > > tokens;\n";
			out += "	ref<tsDeque<std::string> > files;\n";
			
			out += "	size_t run();\n";
			out += "	void lexfile(const std::string&, char**, int&);\n";
			out += "public:\n";
			out += "	Lexer();\n";
			out += "	void init(tsDeque<std::string>&, tsDeque<ptr<TOKEN> >&);\n";
			out += "};\n";
			
			var file = File.write(args[2]+".hpp", false);
			file.writeString(out);
			file.flush();
			file.close();
			
			var out = "";
			out += "#include <"+args[2]+".hpp>\n";
			out += "#include <cstdio>\n";
			out += "#include <string>\n";
			out += "#include <cstring>\n";
			out += "#include <cstdlib>\n";
			out += "#include <iostream>\n";
			out += "#include <caxe_util.hpp>\n";
			
			out += extra+"\n";
			
			out += "TOKEN::TOKEN() {}\n";
			out += "TOKEN::TOKEN(char id) { this->id = id; }\n";
			out += "TOKEN::TOKEN(char id, const Dynamic& data) { this->id = id; this->data = data; }\n";
			
			out += "std::ostream& operator<<(std::ostream& out, const TOKEN& x) {\n";
			out += "	return out << \"{\" << (int)x.id << \", \" << x.data << \"}\";\n";
			out += "}\n";
			
			out += "Lexer::Lexer() {}\n";
			out += "void Lexer::init(tsDeque<std::string>& files, tsDeque<ptr<TOKEN> >& tokens) {\n";
			out += "	this->files = files;\n";
			out += "	this->tokens = tokens;\n";
			out += "}\n";
			
			out += "struct Transition {\n";
			out += "	short state;\n";
			out += "	char flags;\n";
			out += "	union { ptr<TOKEN> (*token)(const std::string&); char id; };\n";
			
			out += "	Transition() { state = -1; flags = 0; token = NULL; }\n";
			out += "	Transition(short a, char b, ptr<TOKEN>(*c)(const std::string&)) { state = a; flags = b; token = c; }\n";
			out += "	Transition(short a, char b) { state = a; flags = b; token = NULL; }\n";
			out += "	Transition(short a, char b, char c) { state = a; flags = b; id = c; }\n";
			out += "};\n";
			
			$(mixin arrstr(x,f,LEFT,RIGHT) {
				var ret = LEFT;
				var fst = true;
				for(i in x) {
					if(!fst) ret += ",";
					fst = false;
					ret += f(i);
				}
				ret += RIGHT;
				ret;
			});

			var states = FaUtil(CharSet).split_states(dfa).all;
			var cnt = 0;
			for(state in states) cnt++;
			
			var map = new StringSet();
			for(state in states) {
				if(!state.accepting) continue;
				var rule = state.attr.func("");
				if(rule.ign) continue;
				
				if(!map.insert(rule.name)) continue;
				if(rule.attr==null) continue;
				
			out += "ptr<TOKEN> token_"+rule.name+"(const std::string& valstr) {\n";
			out += "	Dynamic retval;\n	";
				var esc = false;
				for(i in 0...rule.attr.length) {
					var c = rule.attr.charCodeAt(i);
					if(c==Unicode.wchar('\\') && !esc) {
						esc = true; out += '\\';
					}else if(esc) {
						esc = false; out += rule.attr.charAt(i);
					}else if(c == Unicode.wchar('%')) {
						out += " valstr ";
					}else out += rule.attr.charAt(i);
				}
			out += "	return ptr<TOKEN>(new TOKEN("+(rule.id-1)+",retval));\n";
			out += "}\n";
			}
			
			out += "void err_token(ref<tsDeque<ptr<TOKEN> > >& tokens, std::string& errstr) {\n";
			out += "	if(errstr.length()!=0) {\n";
			if(error_node==null)
			out += "		tokens->push(ptr<TOKEN>(new TOKEN(-1,Dynamic(errstr))));\n";
			else
			out += "		tokens->push(ptr<TOKEN>(new TOKEN("+(error_node.id-1)+",Dynamic(errstr))));\n";
			out += "		errstr.clear();\n";
			out += "	}\n";
			out += "}\n";
			
			out += "#define ET Transition()\n";
			out += "#define T2(a,b) Transition(a,b)\n";
			out += "#define T3(a,b,c) Transition(a,b,c)\n";
			out += "static const Transition transitions["+((RegExp.maxpoint+1)*cnt)+"] = \n";
			out += arrstr(states, function(state:FaNode(CharSet)) {
				var outs = [];
				for(i in 0...RegExp.maxpoint+1) outs.push(null);
				for(out in state.out) {
					var dat = if(out.to.accepting) {
						var rule = out.to.attr.func("");
						var flags = 1;
						var data:String = null;
						if(rule.ign) {}
						else {
							flags |= 2;
							if(rule.attr!=null) {
								flags |= 4;
								data = "&token_"+rule.name;
							}else {
								var rid = rule.id-1;
								data = Std.string(rid);
							}
						}
						{ state : out.to.id, flags : flags, data : data };
					}else
						{ state : out.to.id, flags : 0, data : null };
					
					var x:CharSet = out.match;
					LLIter(R,x.ranges,{
						for(i in R.from...R.to+1) {
							if(out.to.id==-1) outs[i] = null;
							else outs[i] = dat;
						}
					});
				}
				
				return "\n "+arrstr(outs, function(i:{state:Int,flags:Int,data:String}) {
					if(i==null) return "ET";
					else {
						if(i.data==null) return "T2("+Std.string(i.state)+","+Std.string(i.flags)+")";
						else
							return "T3("+Std.string(i.state)+","+Std.string(i.flags)+","+i.data+")";
					}
				},
				"","");
			},
			"{","}");
			out += ";\n";
			out += "#undef ET\n";
			out += "#undef T2\n";
			out += "#undef T3\n";
			
			out += "static const short entry_state = "+dfa.id+";\n";
			out += "static const int maxpoint = "+RegExp.maxpoint+";\n";
			
			var epath = neko.Sys.getEnv("HLEX_ROOT");
			if(epath==null || epath.length==0) {
			    Lib.println("WARNING: HLEX_ROOT NOT DEFINED");
			    epath = "";
			}

			out += File.getContent(epath+"/scripts/hlex_lexer_c++");

			var file = File.write(args[2]+".cpp", false);
			file.writeString(out);
			file.flush();
			file.close();
		}
		else if(!haxemode && !realcpp) {
			
			out += "#include <cstdio>\n";
			out += "#include <string>\n";
			out += "#include <cstring>\n";
			out += "#include <cstdlib>\n";
			out += "using std::string;\n";
			
			out += "const char b0[] = {0xff,0};\n";
			out += "const char b1[] = {0xff,1};\n";
			out += "const char b2[] = {0xff,2};\n";
			out += "inline void hlex_byte(unsigned char c) {\n";
			out += "	switch(c) {\n";
			out += "		case 0xff: fwrite(b0,1,2,stdout); break;\n";
			out += "		case 0x0a: fwrite(b1,1,2,stdout); break;\n";
			out += "		case 0x0d: fwrite(b2,1,2,stdout); break;\n";
			out += "		default:   fputc(c,stdout);\n";
			out += "	}\n";
			out += "}\n";
			
			out += "inline void hlex_string(const string& x) {\n";
			out += "	fputc(1,stdout);\n";
			out += "	fputs(x.c_str(),stdout);\n";
			out += "	fputc(0,stdout);\n";
			out += "}\n";
			
			out += "inline void hlex_int(int x) {\n";
			out += "	fputc(2,stdout);\n";
			out += "	char* xs = (char*)(&x);\n";
			out += "	for(int i = 0; i<4; i++) hlex_byte(xs[i]);\n";
			out += "}\n";
			
			out += "inline void hlex_float(double x) {\n";
			out += "	fputc(3,stdout);\n";
			out += "	char* xs = (char*)(&x);\n";
			out += "	for(int i = 0; i<8; i++) hlex_byte(xs[i]);\n";
			out += "}\n";
			
			out += "\n";
			out += "string valstr;\n";
			out += "string errstr;\n";
			out += "int toks = 0;\n";
			
			out += "inline void err_token() {\n";
			out += "	if(errstr.length()!=0) {\n";
			out += "		fputc(0xfe,stdout);\n";
			out += "		hlex_string(errstr);\n";
			out += "		fputc(0,stdout);\n";
			out += "		errstr.clear();\n";
			out += "\n";
			out += "		if(((++toks)%=100)==0) fflush(stdout);\n";
			out += "	}\n";
			out += "}\n";

			out += "\n";
			
			var states = FaUtil(CharSet).split_states(dfa).all;
			
			out += extra;
			out += "\n";
			var map = new StringSet();
			for(state in states) {
				if(!state.accepting) continue;
				var rule = state.attr.func("");
				if(rule.ign) continue;
				
				if(!map.insert(rule.name)) continue;
				
				if(rule.attr==null) continue; //these don't use functions to build token.
				
			out += "void token_"+rule.name+"() {\n";

				var idd = rule.id-1; //0 = error in rules
				if(idd==10) idd = 124;
				if(idd==13) idd = 125;
				idd |= 0x80;
			out += "	fputc("+idd+",stdout);\n";
			out += "	";
					var esc = false;
					for(i in 0...rule.attr.length) {
						var c = rule.attr.charCodeAt(i);
						if(c==Unicode.wchar('\\') && !esc) {
							esc = true; out += '\\';
						}else if(esc) {
							esc = false; out += rule.attr.charAt(i);
						}else if(c == Unicode.wchar('%')) {
							out += " valstr ";
						}else out += rule.attr.charAt(i);
					}
					out += "\n";
			out += "	fputc(0,stdout);\n";
				
			out += "}\n";
			}
			out += "\n";
			out += "const short entry_state = "+dfa.id+";\n";
			out += "struct Transition {\n";
			out += "	short state;\n";
			out += "	char flags; // !0 = accepting, bit 2 set = ign, bit 3 set = token (T) or id (F)\n";
			out += "	union {\n";
			out += "		void (*token)();\n";
			out += "		char id;\n";
			out += "	};\n";
			out += "};\n";
			out += "#define DT {-1,0,NULL}\n";
			out += "const Transition transitions[] = {\n";
			
			var fst = true;
			for(state in states) {				
				var outs = [];
				for(i in 0...RegExp.maxpoint+1) outs.push(null);
				for(out in state.out) {
					var dat = if(out.to.accepting) {
						var rule = out.to.attr.func("");
						var flags = 1;
						var data = "NULL";
						if(rule.ign) {}
						else {
							flags |= 2;
							if(rule.attr!=null) {
								flags |= 4;
								data = "&token_"+rule.name;
							}else {
								var rid = rule.id-1;
								data = "(void(*)())"+Std.string(rid);
							}
						}
						{ state : out.to.id, flags : flags, data : data };
					}else
						{ state : out.to.id, flags : 0, data : "NULL" };
					
					var x:CharSet = out.match;
					LLIter(R,x.ranges,{
						for(i in R.from...R.to+1) {
							if(out.to.id==-1) outs[i] = null;
							else outs[i] = dat;
						}
					});
				}
				
				for(i in outs) {
					if(!fst) out += ",";
					fst = false;
					out += if(i==null) "DT"
						   else "{"+Std.string(i.state)+","+Std.string(i.flags)+","+i.data+"}";
				}
				out += "\n";
			}
			out += "};\n";
			out += "\n";
			out += "int main(int argc, char** argv) {\n";
			out += "	char* file = NULL;\n";
			out += "	int psize = 0;\n";
			out += "	char addr[0xff]; int adi = 0;\n";
			out += "	while(true) {\n";
			
			out += "		char c = getchar();\n";
			out += "		if(c<32 && adi==0) continue;\n";
			out += "		addr[adi++] = c<32 ? 0 : c;\n";
			out += "		if(c<32) {\n";
			out += "			if(strcmp(addr,\":q\")==0) break;\n";
			out += "			adi = 0;\n";
			out += "		}else continue;\n";
			out += "\n";
			
			out += "		FILE* fp = fopen(addr,\"rb\");\n";
			out += "		if(fp==NULL) return 2;\n";
			out += "\n";
			
			out += "		fseek(fp,0,SEEK_END);\n";
			out += "		int size = ftell(fp);\n";
			out += "		fseek(fp,0,SEEK_SET);\n";
			out += "\n";
			
			out += "		if(size>psize) {\n";
			out += "			file = (char*)realloc(file,size);\n";
			out += "			psize = size;\n";
			out += "		}\n";
			out += "		size = fread(file,1,size,fp);\n";
			out += "		fclose(fp);\n";
			out += "		char* end = file+size;\n";
			out += "\n";
			
			out += "		bool valid = false;\n";
			out += "		Transition attr;\n";
			out += "		int valcnt = 0;\n";
			out += "		char* ipos = file;\n";
			out += "		char* pos = file;\n";
			out += "\n";
			out += "		bool errstate = false;\n";
			out += "\n";
			out += "		short state = entry_state;\n";
			out += "		toks = 0;\n";
			out += "		while(pos<end) {\n";
			out += "			unsigned char c = *pos; //handle unicode?\n";
			out += "			int offset = (c>"+RegExp.maxpoint+" ? "+(RegExp.maxpoint)+" : (int)c);\n";
			out += "			Transition to = transitions[state*"+(RegExp.maxpoint+1)+"+offset];\n";
			out += "			state = to.state;\n";
			out += "\n";
			out += "			if(state==-1) {\n";
			out += "				if(!valid) {\n";
			out += "					if(!errstate) { if(((unsigned char)*ipos)>31) errstr.push_back(*ipos); }\n";
			out += "					else if(c>31) errstr.push_back(c);\n";
			out += "					pos = ipos+1;\n";
			out += "				}else {\n";
			out += "					err_token();\n";
			
			out += "					if(attr.flags&2) {\n";
			out += "						if(attr.flags&4) {\n";
			out += "							pos = ipos;\n";
			out += "							valstr.clear();\n";
			out += "							while(valcnt-->0) valstr.push_back(*(pos++));\n";
			out += "							attr.token();\n";
			out += "						}else {\n";
			out += "							fputc(attr.id,stdout);\n";
			out += "							pos = ipos+valcnt;\n";
			out += "						}\n";
			out += "						if(((++toks)%=100)==0) fflush(stdout);\n";
			out += "					}else pos = ipos+valcnt;\n";
			
			out += "				}\n";
			out += "				errstate = !valid;\n";
			
			out += "				//reset state\n";
			out += "				state = entry_state;\n";
			out += "				valid = false;\n";
			out += "				ipos = pos;\n";
			out += "			}else {\n";
			out += "				pos++;\n";
			out += "				errstate = false;\n";
			out += "			}\n";
			
			out += "\n";
			out += "			if(to.flags) {\n";
			out += "				valid = true;\n";
			out += "				valcnt = pos-ipos;\n";
			out += "				attr = to;\n";
			out += "			}else if(pos==end) {\n";
			out += "				if(!valid) {\n";
			out += "					if(!errstate) { if(((unsigned char)*ipos)>31) errstr.push_back(*ipos); }\n";
			out += "					pos = ipos+1;\n";
			out += "				}else {\n";
			out += "					err_token();\n";
			
			out += "					if(attr.flags&2) {\n";
			out += "						if(attr.flags&4) {\n";
			out += "							pos = ipos;\n";
			out += "							valstr.clear();\n";
			out += "							while(valcnt-->0) valstr.push_back(*(pos++));\n";
			out += "							attr.token();\n";
			out += "						}else {\n";
			out += "							fputc(attr.id,stdout);\n";
			out += "							pos = ipos+valcnt;\n";
			out += "						}\n";
			out += "						if(((++toks)%=100)==0) fflush(stdout);\n";
			out += "					}else pos = ipos+valcnt;\n";
			
			out += "				}\n";
			out += "				errstate = !valid;\n";
			
			out += "				//reset state\n";
			out += "				state = entry_state;\n";
			out += "				valid = false;\n";
			out += "				ipos = pos;\n";
			out += "			}\n";
			out += "		}\n";
			
			out += "		if(ipos<end) {\n";
			out += "			if(!valid) {\n";
			out += "				if(!errstate) { if(((unsigned char)*ipos)>31) errstr.push_back(*ipos); }\n";
			out += "				else if(c>31) errstr.push_back(c);\n";
			out += "				pos = ipos+1;\n";
			out += "			}else {\n";
			out += "				err_token();\n";

			out += "				if(attr.flags&2) {\n";
			out += "					if(attr.flags&4) {\n";
			out += "						pos = ipos;\n";
			out += "						valstr.clear();\n";
			out += "						while(valcnt-->0) valstr.push_back(*(pos++));\n";
			out += "						attr.token();\n";
			out += "					}else {\n";
			out += "						fputc(attr.id,stdout);\n";
			out += "						pos = ipos+valcnt;\n";
			out += "					}\n";
			out += "					if(((++toks)%=100)==0) fflush(stdout);\n";
			out += "				}else pos = ipos+valcnt;\n";
			
			out += "			}\n";
			out += "		}\n";
			
			out += "		err_token();\n";
			
			out += "		fputc(0x7f,stdout);\n";
			out += "		fflush(stdout);\n";
			
			out += "	}\n";
			out += "	return 0;\n";
			out += "}\n";
			
			var file = File.write(".temp.hlex.cpp", false);
			file.writeString(out);
			file.flush();
			file.close();
			
			neko.Lib.println(" >> g++ compilation.");
			
			if(neko.Sys.command("g++",[".temp.hlex.cpp","-s","-O3","-funroll-loops","-fexpensive-optimizations","-o",args[2]])!=0)
				Sys.exit(1);
			
			var epath = neko.Sys.getEnv("HLEX_ROOT");
			if(epath==null || epath.length==0) {
			    Lib.println("WARNING: HLEX_ROOT NOT DEFINED");
			    epath = "";
			}
			
			file = File.write(args[3], false);
			file.writeString(File.getContent(epath+"/scripts/hlex_utils"));
			file.flush();
			file.close();
		}else if(!newhaxe) {
			
			out += "package "+packname+";\n";
			out += "\n";
			out += extra;
			out += "\n";
			out += "class HLex {\n";
			
			//--------------------------------------------------------------------------------------
			
			out += "	    static inline var entry_state:Int = "+dfa.id+";\n";
			out += "\n";
			
			var states = FaUtil(CharSet).split_states(dfa).all;
			out += "        static var transitions = ";
			out += Textual.array_string(cast states, function(state:FaNode(CharSet)) {
				var outs = [];
				for(i in 0...RegExp.maxpoint+1) outs.push(-1);
				
				for(out in state.out) {
					var x:CharSet = out.match;
					LLIter(R, x.ranges, {
						for(i in R.from...R.to+1)
							outs[i] = out.to.id;
					});
				}
				return Textual.array_string(cast outs);
			});
			out += ";\n";
			
			//--------------------------------------------------------------------------------------
			
			out += "\n";
			out += "        static var accepting = ";
			out += Textual.array_string(cast states, function(state:FaNode(CharSet)) {
				return if(state.accepting) "true" else "false";
			});
			out += ";\n";
			
			//--------------------------------------------------------------------------------------
			
			out += "\n";
			out += "	public static function lexify(input_string:String):Array<Token> {\n";
			
			//--------------------------------------------------------------------------------------
			
			var epath = neko.Sys.getEnv("HLEX_ROOT");
			if(epath==null || epath.length==0) {
			    Lib.println("WARNING: HLEX_ROOT NOT DEFINED");
			    epath = "";
			};
			
			out += File.getContent(epath+"/scripts/hlex_lexer");
			
			//--------------------------------------------------------------------------------------
			
			out += "	}\n";
			
			out += "    static inline function tokenof(id:Int, hxl_ustr:UStr):Token {\n";
			out += "        switch(id) {\n";
			out += "            default: return null;\n";
			for(x in states) {
				if(!x.accepting || x.attr==null) continue;
				var rule = x.attr.func("");
				if(rule.ign) continue;
				out += "            case "+x.id+":\n";
				out += "                var hxl_match = Unicode.string(hxl_ustr);\n";
				out += "                return Token.get(Token.t_"+rule.name+",";
				if(rule.attr != null) {
					out += "({";
					var esc = false;
					for(i in 0...rule.attr.length) {
						var c = rule.attr.charCodeAt(i);
						if(c==Unicode.wchar('\\') && !esc) {
							esc = true; out += '\\';
						}else if(esc) {
							esc = false; out += rule.attr.charAt(i);
						}else if(c == Unicode.wchar('%')) {
							out += " hxl_match ";
						}else out += rule.attr.charAt(i);
					}
					out += "})";
				}else out += "null";
				out += ");\n";
			}
			out += "        }\n";
			out += "    }\n";
			out += "}\n";
			
			//--------------------------------------------------------------------------------------
			
			out += "class Token {\n";
			out += "	public var data:Dynamic;\n";
			out += "	public var id:Int;\n";
			out += "\n";
			out += "	public var pool_next:Token;\n";
			out += "    public static var pool:Token;\n";
			out += "\n";
			for(xs in rules) {
				var x = xs.data;
				if(x.ign) continue;
				out += "	public static inline var t_"+x.name+" = "+x.id+";\n";
			}
			out += "\n";
			out += "	public static inline var t_error = 0;\n";
			out += "\n";
			out += "    static inline public function get(id:Int, data:Dynamic) {\n";
			out += "        if(pool==null) return new Token(id,data);\n";
			out += "        else {\n";
			out += "            var ret = pool; pool = ret.pool_next;\n";
			out += "            ret.id = id; ret.data = data;\n";
			out += "            return ret;\n";
			out += "        }\n";
			out += "    }\n";
			out += "    public inline function free() { pool_next = pool; pool = this; }\n";
			out += "	function new(id:Int, data:Dynamic) {\n";
			out += "		this.id = id; this.data = data;\n";
			out += "	}\n";
			out += "\n";
			out += "	public inline function toString() {\n";
			var rmap = new IntMap(String)(); //to order by id rather than name
			for(xs in rules) {
				if(xs.data.ign) continue;
				rmap.insert(xs.data.id,xs.data.name);
			}

			out += "        var names = [\"error\"].concat(";
			out += Textual.array_string(cast rmap, function(x:{data:String}) return "\""+x.data+"\"");
			out += ");\n";
			
			out += "		return names[id]+(data==null?\"\":\"(\"+data+\")\");\n";
			out += "	}\n";
			out += "}\n";
			
			//--------------------------------------------------------------------------------------
			
			out += File.getContent(epath+"/scripts/hlex_ustr");
			
			var file = File.write(args[2], false);
			file.writeString(out);
			file.flush();
			file.close();
		}else {
			out += "package "+packname+";\n";
			out += "\n";
			out += extra;
			out += "\n";
			out += "class HLex {\n";
			
			out += "		static inline var entry_state:Int = "+dfa.id+";\n";
			out += "\n";
	
/*			var states = FaUtil(CharSet).split_states(dfa).all;
			out += "        static var transitions = ";
			out += Textual.array_string(cast states, function(state:FaNode(CharSet)) {
				var outs = [];
				for(i in 0...RegExp.maxpoint+1) outs.push(-1);
				
				for(out in state.out) {
					var x:CharSet = out.match;
					LLIter(R, x.ranges, {
						for(i in R.from...R.to+1)
							outs[i] = out.to.id;
					});
				}
				return Textual.array_string(cast outs);
			});
			out += ";\n";*/

			out += "	static var transitions:Array<Array<Array<Int>>> = null;\n";
			out += "	public static function init() {\n";
			out += "		if(transitions!=null) return;\n";
			out += "		transitions = [];\n";
			var states = FaUtil(CharSet).split_states(dfa).all;
			for(state in states) {
				if(state.out.length==0) { out += "transitions.push(null);\n"; continue; }
				out += "var cur = [];\n";
				for(ssout in state.out) {
					var x:CharSet = ssout.match;
					LLIter(R, x.ranges, {
						out += "cur.push(["+(R.from)+","+(R.to)+","+(ssout.to.id)+"]);\n";	
					});
				}
				out += "transitions.push(cur);\n";
			}
			out += "}\n";

			//--------------------------------------------------------------------------------------
			
			out += "\n";
			out += "        static var accepting = ";
			out += Textual.array_string(cast states, function(state:FaNode(CharSet)) {
				return if(state.accepting) "true" else "false";
			});
			out += ";\n";
			
			//--------------------------------------------------------------------------------------
			
			out += "\n";
			out += "	public static function lexify(input:String):Array<Token> {\n";
			out += "		init();\n";	
			//--------------------------------------------------------------------------------------
			
			var epath = neko.Sys.getEnv("HLEX_ROOT");
			if(epath==null || epath.length==0) {
			    Lib.println("WARNING: HLEX_ROOT NOT DEFINED");
			    epath = "";
			};
			
			out += File.getContent(epath+"/scripts/hlex_lexer_new");

			out += "}\n";

			out += "	static inline function errtok(hxl_match:String) {\n";
			if(error_attr==null) out += "		return null;\n";
			else {
				out += "return ({";
					var esc = false;
					for(i in 0...error_attr.length) {
						var c = error_attr.charCodeAt(i);
						if(c==Unicode.wchar('\\') && !esc) {
							esc = true; out += '\\';
						}else if(esc) {
							esc = false; out += error_attr.charAt(i);
						}else if(c == Unicode.wchar('%')) {
							out += " hxl_match ";
						}else out += error_attr.charAt(i);
					}
				out += "});\n";
			}
			out += "	}\n";

			out += "	static function tokenof(id:Int, hxl_match:String) {\n";
			out += "		switch(id) {\n";
			out += "			default: return null;\n";
			for(x in states) {
				if(!x.accepting || x.attr==null) continue;
				var rule = x.attr.func("");
				if(rule.ign) continue;
				out += "            case "+x.id+":\n";
				out += "				return ";
				if(rule.attr != null) {
					out += "({";
					var esc = false;
					for(i in 0...rule.attr.length) {
						var c = rule.attr.charCodeAt(i);
						if(c==Unicode.wchar('\\') && !esc) {
							esc = true; out += '\\';
						}else if(esc) {
							esc = false; out += rule.attr.charAt(i);
						}else if(c == Unicode.wchar('%')) {
							out += " hxl_match ";
						}else out += rule.attr.charAt(i);
					}
					out += "})";
				}else out += "null";
				out += ";\n";
			}
			out += "        }\n";
			out += "	}\n";
			out += "}\n";

			var file = File.write(args[2], false);
			file.writeString(out);
			file.flush();
			file.close();
		}

		Sys.exit(0);
		return;
	}
}


class CharRangeInt {
	public var from:WChar;
	public var to  :WChar;
	public var target:Int;
	
	public function new(from:WChar, to:WChar, target:Int) {
		this.from = from;
		this.to = to;
		this.target = target;
	}
	
	public inline function compare(x:CharRangeInt) {
		if     (from < x.from) return -1;
		else if(from > x.from) return 1;
		else if(to < x.to) return -1;
		else if(to > x.to) return 1;
		else return 0;
	}
}
