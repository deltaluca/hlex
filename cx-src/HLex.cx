package ;


class HLex {
	    static inline var entry_state:Int = 7;

        static var transitions = [[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,22,22,22,22,22,22,22,22,22,22,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1].concat([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]).concat([1,1,1,1,1,1,1,1,1]),[-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1].concat([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]).concat([1,1,1,1,1,1,29,1,1]),[-1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3].concat([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]).concat([3,3,3,3,3,3,3,3,3]),[-1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3].concat([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]).concat([3,3,3,3,3,30,3,3,3]),[-1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5].concat([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]).concat([5,5,5,5,5,5,5,5,5]),[-1,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,5,5,5,5,32,5,5,5,5,5,5,5,5,5,5,5,5].concat([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]).concat([5,5,5,5,5,5,5,5,5]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,34,34,-1,-1,34,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,34,-1,-1,-1,-1,10,-1,-1,23,24,-1,0,-1,0,-1,8,22,22,22,22,22,22,22,22,22,22,25,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,19,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,13,11,11,11,17,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,9,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,-1,-1,-1,-1,33,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,3,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,15,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,31,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,28,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,18,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,16,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,14,11,11,11,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,21,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,27,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,20,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,22,22,22,22,22,22,22,22,22,22,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,26,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,-1,-1].concat([-1,-1,-1,-1,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-1,-1,-1,-1,11,-1,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11]).concat([11,11,11,-1,-1,-1,-1,-1,-1]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1]),[-1,33,33,33,33,33,33,33,33,33,-1,33,33,-1,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33].concat([33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33]).concat([33,33,33,33,33,33,33,33,33]),[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1].concat([-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]).concat([-1,-1,-1,-1,-1,-1,-1,-1,-1])];

        static var accepting = [false,false,false,false,false,false,false,false,false,false,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true];

	public static function lexify(input_string:String):Array<Token> {
var input = Unicode.fromString(input_string);
var ret = new Array<Token>();
var valid = false;
var valcnt = 0;
var attr = 0;
var errstate = false;
var errstr:UStr = null;

var state = entry_state;
var pos = 0;
var ipos = pos;

while(pos < input.length) {
	//evaluate next state to progress to.
	var trans = transitions[state];
	var char = input[pos];

	state = if(char>=trans.length) trans[trans.length-1];
	else trans[char];
	
	if(state==-1) {
		//ERROR?
		if(!valid) {
			if(!errstate) {
			    if(errstr==null)
				    errstr = [input[ipos]];
				else
				    errstr.push(input[ipos]);
			}
			else errstr.push(char);
			pos = ipos+1;
		}else {
			if(errstr!=null) {
				ret.push(Token.get(Token.t_error,Unicode.string(errstr)));
				errstr = null;
			}
			var tok = tokenof(attr,Unicode.substr(input,ipos,valcnt));
			//var cb = tokens[attr];
			//if(cb!=null)
			//	ret.push(cb(Unicode.string(Unicode.substr(input,ipos,valcnt))));
			if(tok!=null) ret.push(tok);
			pos = ipos+valcnt;
		}
		errstate = !valid;

		//reset state
		state = entry_state;
		valid = false;
		ipos = pos;
	}else {
	    pos++;
	    errstate = false;
	}

	//accepting state reached? persevere anyways!
	if(accepting[state]) {
		valid = true;
		//if(identb) pos--;
		valcnt = pos-ipos;
		attr = state;
	}else if(pos==input.length) {
	    //ERROR?
		if(!valid) {
			if(!errstate) {
			    if(errstr==null)
				    errstr = [input[ipos]];
				else
				    errstr.push(input[ipos]);
			}
			else errstr.push(input[pos]);
			pos = ipos+1;
		}else {
			if(errstr!=null) {
				ret.push(Token.get(Token.t_error,Unicode.string(errstr)));
				errstr = null;
			}
			var tok = tokenof(attr,Unicode.substr(input,ipos,valcnt));
			//var cb = tokens[attr];
			//if(cb!=null)
			//	ret.push(cb(Unicode.string(Unicode.substr(input,ipos,valcnt))));
			if(tok!=null) ret.push(tok);
			pos = ipos+valcnt;
		}
		errstate = !valid;

		//reset state
		state = entry_state;
		valid = false;
		ipos = pos;
	}
}

if(ipos<input.length) {
	//ERROR?
	if(!valid) {
	    ret.push(Token.get(Token.t_error,Unicode.string(Unicode.substr(input,ipos))));
	} else {
		if(errstr!=null) {
			ret.push(Token.get(Token.t_error,Unicode.string(errstr)));
			errstr = null;
		}
		var tok = tokenof(attr,Unicode.substr(input,ipos,valcnt));
        //var cb = tokens[attr];
        //if(cb!=null)
        //	ret.push(cb(Unicode.string(Unicode.substr(input,ipos,valcnt))));
        if(tok!=null) ret.push(tok);
		pos = ipos+valcnt;
	}
}
if(errstr!=null) {
	ret.push(Token.get(Token.t_error,Unicode.string(errstr)));
	errstr = null;
}

return ret;	}
    static inline function tokenof(id:Int, hxl_ustr:UStr):Token {
        switch(id) {
            default: return null;
            case 11:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 12:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 13:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 14:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 15:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 16:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 17:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 18:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 19:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 20:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 21:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_ident,({  hxl_match ; }));
            case 22:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_int,({ Std.parseInt( hxl_match ); }));
            case 23:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_lpar,null);
            case 24:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_rpar,null);
            case 25:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_colon,null);
            case 26:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_coleq,null);
            case 27:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_NULLx,null);
            case 28:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_attrx,null);
            case 29:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_regexp,({  hxl_match .substr(2, hxl_match .length-4); }));
            case 30:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_haxe,({  hxl_match .substr(2, hxl_match .length-4); }));
            case 31:
                var hxl_match = Unicode.string(hxl_ustr);
                return Token.get(Token.t_err,null);
        }
    }
}
class Token {
	public var data:Dynamic;
	public var id:Int;

	public var pool_next:Token;
    public static var pool:Token;

	public static inline var t_NULLx = 7;
	public static inline var t_attrx = 8;
	public static inline var t_coleq = 6;
	public static inline var t_colon = 5;
	public static inline var t_err = 11;
	public static inline var t_haxe = 10;
	public static inline var t_ident = 1;
	public static inline var t_int = 2;
	public static inline var t_lpar = 3;
	public static inline var t_regexp = 9;
	public static inline var t_rpar = 4;

	public static inline var t_error = 0;

    static inline public function get(id:Int, data:Dynamic) {
        if(pool==null) return new Token(id,data);
        else {
            var ret = pool; pool = ret.pool_next;
            ret.id = id; ret.data = data;
            return ret;
        }
    }
    public inline function free() { pool_next = pool; pool = this; }
	function new(id:Int, data:Dynamic) {
		this.id = id; this.data = data;
	}

	public inline function toString() {
        var names = ["error"].concat(["ident","int","lpar","rpar","colon","coleq","NULLx","attrx","regexp","haxe","err"]);
		return names[id]+(data==null?"":"("+data+")");
	}
}
#if neko
	import haxe.Int32;
#end

typedef WChar = Int;
typedef UStr = Array<WChar>;
class Unicode {
	
	public static inline function concat(a:UStr, x:UStr) {
		for(i in x) a.push(cast x);
	}
	
	public static inline function substr(str:UStr, pos:Int, ?cnt:Int = -1) {
		if(cnt==-1) cnt = str.length-pos;
		var ret = new UStr();
		var max = pos+cnt;
		if(max>str.length) max = str.length;
		for(i in pos...max) ret.push(str[i]);
		return ret;
	}
	
	public static inline function wchar(x:String) return fromString(x)[0]
	
	#if neko
		public static inline function parseInt(x:String):Int32 {
			var ret = Int32.ofInt(0);
			for(i in 0...x.length) {
				ret = Int32.mul(ret,Int32.ofInt(10));
				ret = Int32.add(ret,Int32.ofInt(Std.parseInt(x.charAt(i))));
			}
			return ret;
		}
	
		//neko uses a very weird encoding scheme.

		//this is not guaranteed to be correct! but it works for what i've tested and analysed.
		//it is limited to unicode points <= 0xffff though. so doesn't handle full unicode.
		public static inline function string(str:UStr):String {
			var ret = new StringBuf();
			for(i in str) {
				if(i<0x80) ret.addChar(i);
				else if(i<0xfff) {
					var c0 = i&0x3f;
					i >>>= 6;
					var c1 = i&0x3f;
					
					ret.addChar(0xc0 | c1);
					ret.addChar(0x80 | c0);
				}else {
					var c0 = i&0x3f;
					i >>>= 6;
					var c1 = i&0x3f;
					i >>>= 6;
					var c2 = i&0x1f;
					
					ret.addChar(0xe0 | c2);
					ret.addChar(0x80 | c1);
					ret.addChar(0x80 | c0);
				}
			}
			return ret.toString();
		}
		public static inline function fromString(str:String):UStr {
			var ret = new UStr();
			var pos = 0;
			while(pos<str.length) {
				var c0 = str.charCodeAt(pos++);
				if((c0&0x80)==0) ret.push(c0);
				else if((c0&0xc0)==0x80) {
					var acc = c0&0x3f;
					acc |= ((c0=str.charCodeAt(pos++))&0x3f)<<6;
					if((c0&0xc0)==0x80)
						acc |= ((c0=str.charCodeAt(pos++))&0x1f)<<12;
					ret.push(acc);
				}else if((c0&0xe0)==0xe0) {
					var acc = (c0&0x1f)<<12;
					acc |= ((str.charCodeAt(pos++))&0x3f)<<6;
					acc |= (str.charCodeAt(pos++))&0x3f;
					ret.push(acc);
				}else if((c0&0xe0)==0xc0) {
					var acc = (c0&0x3f)<<6;
					acc |= (str.charCodeAt(pos++))&0x3f;
					ret.push(acc);
				}else break;
			}
			return ret;
		}
	#elseif flash
		
		public static inline function parseInt(x:String) return Std.parseInt(x)
	
		//flash uses nice simple wrapped unicode :)
		public static inline function fromString(str:String):UStr {
			var ret = new UStr();
			for(i in 0...str.length) ret.push(str.charCodeAt(i));
			return ret;
		}
		public static inline function string(str:UStr):String {
			var ret = new StringBuf();
			for(i in str) ret.addChar(i);
			return ret.toString();
		}
	
	#end
}